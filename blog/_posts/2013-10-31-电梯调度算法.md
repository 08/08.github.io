---
layout: post
title: 电梯调度算法
author: Ethan
---

先看看一种简单的情形，楼层为N, 去第i层的人数为p[i], 电梯只在一个楼层停，走上一层楼，走下一层楼和乘电梯上一层需要消耗能量分别为k1, k2, k3.
分别寻找使走的总楼层数最小时和消耗能量最少时对应的电梯停靠楼层。

  1、遍历楼层, 时间复杂度为O(N*N)

      目标函数1: min T(i), 所有人走的楼层总数最小值
      目标函数2: min E(i), 所有人消耗能量最小值

      p[i]: 去i层的人数。
      |j-i|: 电梯停在第i层时去第j层的人要走的楼层。

      所有人走的楼层总数: T(i)=∑(p[j]*|j-i|), j=1, ..., N

      坐电梯上楼消耗能量: E1(i)=k3*(i-1)*∑p[j], j=1, ..., N
      走路上下楼消耗能量: E2(i)=∑(p[j]*|j-i|*((j-i)?k1:k2)), j=1, ..., N
      总的消耗能量: E(i)=E1(i)+E2(i)


  2、动态规划，时间复杂度为O(N)

      i, j: 1~N
      p[i]: 去i层的人数。
      |j-i|: 电梯停在第i层时去第j层的人要走的楼层。

      归纳假设, 假设电梯停在第i层时，
                  所有人走的楼层总数为Q(i), 消耗能量总数E(i);
                  要到1至(i-1)层的人数总数为S1, 要到i层的人数总数为S2, 要到(i+1)至N层的人数总数为S3;
                  / 对应的人群消耗能量分别为W1, W2, W3.(注：Q(1)= ∑(p[j]*|j-1|), j=1, ..., N;
                  / E(i)=W1+W2+W3)

              那么电梯停在第(i+1)层时, 要到1至i层的人需要多下一层楼，他们走的楼层总数增加S1+S2, 消耗能量增加
                  (S1+S2)*(k2+k3)， 要到(i+1)至N层的人走可
                  以少上一层楼， 他们走的楼层总数减少S3, 消耗能量变化
                  S3*(k3-k1),(实际上考虑k3<k1的情况，消耗能量减少S3*(k1-k3)）

                  此时所有人走的楼层总数Q(i+1)=Q(i)+S1+S2-S3;
                  消耗能量总数E(i+1)=E(i)+(S1+S2)*(k2+k3)－S3*(k1-k3)；

       可以看出随着电梯所停楼层i的增加, S1+S2也是不断增大的，而S3不断减小的。
                      对应的(S1+S2)*(k2+k3)不断增大，考虑k3<k1的情况，S3*(k1-k3)不断减小。

       S1=∑p[k], k=1，..., i-1
       S2=p[i]
       S3=∑p[k], k=(i+1), ..., N
        电梯停在第1层时，S1=0, S2=p[1], S3=∑p[k], k=2~N
       当S1+S2<S3时， Q(i)是递减的；
       当S1+S2>S3时， Q(i)是递增的；

       所有人走的楼层总数的最小值在S1+S2<S3的最后一次取得；


          W1=k3*∑(p[k]*(i-1))+k2*∑p[k]*(i-k), k=1, ..., i-1
          W2=k3*p[i]*(i-1)
          w3=k3*∑(p[k]*(i-1))+k1*∑p[k]*(k-i), k=i+1, ..., N
        电梯停在第1层时，W1=0, W2=0, W3=k1*∑p[k]*(k-1), k=2~N

       当(S1+S2)*(k2+k3)<S3*(k1-k3)时， E(i)是递减的；
       当(S1+S2)*(k2+k3)>S3*(k1-k3)时， E(i)是递增的；

          所有人消耗能量的最小值在(S1+S2)*(k2+k3)<S3*(k1-k3)的最后一次取得。


  3、最佳一致逼近，零点附近给出极值;
 
  这里提供源代码以供参考[ElevatorScheduler](https://github.com/iBeacons/MacAppDev)
